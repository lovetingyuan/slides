/* empty css                       */document.title="{{ title }}";document.title="Vue2 SSR";const n=document.querySelector('link[rel="icon"]')||document.createElement("link");n.rel="icon",n.href="/slides/assets/logo.277e0e97.svg",document.head.appendChild(n);var e='<section >\n\n\n<h3 id="vue-ssr">VUE SSR</h3>\n<section >\n\n<ul>\n<li>概念</li>\n<li>流程</li>\n<li>实现</li>\n<li>问题</li>\n<li>部署</li>\n</ul>\n</section>\n\n</section>\n\n<section >\n\n\n \n\n<section >\n\n<h3 id="什么是服务端渲染">什么是服务端渲染</h3>\n<p>  在服务端渲染vue组件，将生成的html返回</p>\n<pre><code class="language-javascript">    const App = require(&#39;App.vue&#39;) // root component\n    const app = new Vue({\n      render(h) { return h(App) }\n    })\n    server.get(&#39;/&#39;, (req, res) =&gt; {\n      res.type = &#39;html&#39;\n      res.body = renderToHtml(app)\n    })\n</code></pre>\n</section>\n\n<section >\n\n<p>  和prerender有何不同？</p>\n<ul>\n<li>prerender是将应用跑在浏览器环境得到的html</li>\n<li>SSR是将单个组件通过框架运行时得出渲染后的html</li>\n</ul>\n</section>\n\n</section>\n\n<section >\n\n\n<h3 id="vue-ssr的流程">Vue SSR的流程</h3>\n<p>  <img src="/slides/vue-ssr/ssr.png" alt="Vue SSR的流程图"></p>\n</section>\n\n\n\n<include_Li93ZWJwYWNrLm1k>\n\n\n\n\n<include_Li9yZW5kZXJlci5tZA>\n\n\n\n\n<include_Li9pc3N1ZS5tZA>\n\n\n\n\n<include_Li9hc3luYy5tZA>\n\n\n\n\n<include_Li9jYWNoZS5tZA>\n\n\n\n\n<section >\n\n\n<p>部署</p>\n<section >\n\n<ul>\n<li>项目部署配置修改</li>\n<li>使用 forever, pm2 等工具</li>\n<li>nginx 配置修改</li>\n</ul>\n</section>\n\n</section>\n\n<section >\n\n\n<p>  Vue2 SSR 官方指南</p>\n<p>  <a href="href=%22https://ssr.vuejs.org/%22">https://ssr.vuejs.org/</a></p>\n<hr>\n<p>  Thanks, Q&amp;A</p>\n</section>\n\n'.replace("<include_Li93ZWJwYWNrLm1k>",'<section >\n\n\n<h4 id="webpack-打包">Webpack 打包</h4>\n<section >\n\n<ul>\n<li>将应用打包为commonjs的格式，将根组件作为默认导出即可</li>\n<li>这样nodejs就可以获取到应用的根组件了</li>\n</ul>\n</section>\n\n<section >\n\n<p>  现在需要增加一份专门为node环境打包的webpack</p>\n<pre><code class="language-javascript">  {\n    outputDir: &#39;dist/ssr&#39;,\n    productionSourceMap: false,\n    css: {\n      extract: false // 关闭提取css的功能\n    },\n    configureWebpack: {\n      entry: {\n        app: [\n          &#39;./src/server-main.js&#39; // 服务端的入口文件\n        ]\n      },\n      target: &#39;node&#39;, // 目标设置为node环境\n      output: {\n        libraryTarget: &#39;commonjs2&#39; // 打包导出的格式为commonjs\n      },\n      externals: nodeExternals({ // 不打包node_modules中的包\n        whitelist: /\\.(css|svg)$/\n      }),\n      optimization: { // 关闭压缩和分包功能\n        minimize: false,\n        splitChunks: false\n      },\n      plugins: [\n        // require(&#39;vue-server-renderer/server-plugin&#39;) 引入vue ssr的插件\n        new VueSSRServerPlugin(),\n        new webpack.DefinePlugin({\n          &#39;process.env&#39;: {\n            VUE_ENV: JSON.stringify(({}).VUE_ENV)\n          }\n        }),\n      ]\n    },\n  }\n</code></pre>\n</section>\n\n<section >\n\n<ul>\n<li>上面打包出来只会生成一个名为<code>vue-ssr-server-bundle.json</code>的文件</li>\n<li>这个文件包含了服务端所有的代码</li>\n</ul>\n</section>\n\n<section >\n\n<p>  浏览器端打包也需要小小的改动</p>\n<pre><code class="language-javascript">{\n  configureWebpack: {\n    optimization: {\n      runtimeChunk: {\n        // 将webpack运行时分包，以便渲染器注入正确的资源标签\n        name: &#39;manifest&#39;\n      }\n    },\n  },\n  plugins: [\n    // require(&#39;vue-server-renderer/client-plugin&#39;)，引入客户端的插件\n    new VueSSRClientPlugin(),\n  ]\n}\n</code></pre>\n</section>\n\n<section >\n\n<ul>\n<li>上面的插件会额外生成<code>vue-ssr-client-manifest.json</code></li>\n<li>这个文件包含了所有模块和文件的依赖关系，打包结果等</li>\n</ul>\n</section>\n\n</section>\n\n').replace("<include_Li9yZW5kZXJlci5tZA>",'<section >\n\n\n<h4 id="渲染器">渲染器</h4>\n<section >\n\n<pre><code class="language-javascript">const { createBundleRenderer } = require(&#39;vue-server-renderer&#39;)\nconst renderer = createBundleRenderer(\n  require(&#39;./dist/ssr/vue-ssr-server-bundle.json&#39;),\n  {\n    template: fs.readFileSync(&#39;./dist/ssr/index.html&#39;, &#39;utf8&#39;),\n    runInNewContext: false,\n    clientManifest: require(&#39;./dist/ssr/vue-ssr-client-manifest.json&#39;)\n  }\n)\nfunction SSRMiddleware (ctx) {\n  const context = { // 渲染上下文\n    url: ctx.url\n  }\n  return renderer.renderToString(context).then(html =&gt; {\n    ctx.type = &#39;html&#39;\n    ctx.body = html\n  })\n}\n</code></pre>\n</section>\n\n<section >\n\n<p>  <img src="/slides/vue-ssr/vue-ssr.png" alt="webpack"></p>\n</section>\n\n<section >\n\n<p>  渲染上下文和模板</p>\n<ul>\n<li>渲染上下文是node环境和app沟通的桥梁</li>\n<li>其实就是一个全局共享的对象而已，可以注入任何值</li>\n<li>渲染模板就是最终返回的html的模板，支持mustache插值</li>\n<li>vue-server-render会自动为模板注入 critical CSS，store state，preload, prefetch, script, link等标签</li>\n</ul>\n</section>\n\n<section >\n\n  <br>\n  \n<p>  header标签</p>\n<pre><code class="language-javascript">Vue.mixin({\n  created () {\n    const title = getTitle(this) || &#39;default title&#39;\n    this.$ssrContext.title = title\n  }\n})\n</code></pre>\n<pre><code class="language-html">&lt;html&gt;\n  &lt;head&gt;\n    \n  &lt;/head&gt;\n  &lt;body&gt; ... &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n</section>\n\n<section >\n\n  <br>\n\n<p>  如何渲染特定路由？</p>\n<p>  将用户请求信息通过 context 传递到代码中</p>\n<pre><code class="language-javascript">export default context =&gt; {\n  const router = createRoute()\n  const store = createStore()\n  const app = createApp(router, store, App)\n  const { url } = context;\n  router.push(url.replace(({}).BASE_URL, &#39;&#39;));\n  return new Promise.resolve((resolve) =&gt; {\n    router.onReady(() =&gt; {\n      resolve(app)\n    })\n  })\n}\n</code></pre>\n</section>\n\n</section>\n\n').replace("<include_Li9pc3N1ZS5tZA>","<section >\n\n\n<p>面对的问题</p>\n<section >\n\n<ul>\n<li>有的代码只能在浏览器运行怎么办</li>\n<li>用户数据的隔离(session)</li>\n<li>异步数据获取(async data)</li>\n</ul>\n</section>\n\n<section >\n\n<p>  有的代码只能在浏览器运行怎么办</p>\n<ul>\n<li>平台相关的代码惰性访问<ul>\n<li>vue在服务器环境只会执行 beforeCreate 和 created 这两个钩子</li>\n</ul>\n</li>\n<li>通过环境变量条件执行<ul>\n<li>通过 webpack.DefinePlugin 来设置环境变量</li>\n</ul>\n</li>\n</ul>\n</section>\n\n<section >\n\n<p>  用户的请求环境怎么隔离开</p>\n<ul>\n<li>单例模式 =&gt; 工厂模式<ul>\n<li>将根实例，vuex store， vue router 等都改为工厂方法</li>\n</ul>\n</li>\n</ul>\n</section>\n\n</section>\n\n").replace("<include_Li9hc3luYy5tZA>",'<section >\n\n\n<h4 id="数据预取">数据预取</h4>\n<section >\n\n<ul>\n<li>为什么数据需要预取？</li>\n<li>在哪里预取数据？</li>\n<li>取得的数据放在哪里？</li>\n</ul>\n</section>\n\n<section >\n\n<p>  为什么数据需要预取？</p>\n<ul>\n<li>因为本质上SSR是个同步过程，仅执行组件初始化渲染</li>\n<li>所以SSR在渲染组件之前必须获取到组件需要的数据</li>\n</ul>\n</section>\n\n<section >\n\n<p>  在哪里预取数据？</p>\n<ul>\n<li>Vue并不知道组件会在何处何时发出请求</li>\n<li>所以我们可以在组件上约定一个获取数据的方法，返回一个promise</li>\n</ul>\n</section>\n\n<section >\n\n<p>  取得的数据放在哪里？</p>\n<ul>\n<li>取得的数据无法放在组件内</li>\n<li>所以需要放在Vuex的store中</li>\n</ul>\n</section>\n\n<section >\n\n<p>  组件定义</p>\n<pre><code class="language-javascript">export default {\n  // SSR会调用这个钩子预取数据，必须返回promise\n  serverPrefetch () {\n    return this.fetchItem()\n  },\n  methods: {\n    fetchItem () {\n      return this.$store.dispatch(&#39;fetchItem&#39;, this.$route.params.id)\n    }\n  },\n}\n</code></pre>\n</section>\n\n<section >\n\n<p>  根组件解析完毕后，将预取数据填充到context中</p>\n<pre><code class="language-javascript">export default context =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    const { app, router, store } = createApp()\n    router.push(context.url)\n    router.onReady(() =&gt; {\n      const matchedComponents = router.getMatchedComponents()\n      if (!matchedComponents.length) {\n        return reject({ code: 404 })\n      }\n      context.rendered = () =&gt; {\n        // 渲染器会将state序列化为window.__INITIAL_STATE__并填充到模板中\n        context.state = store.state\n      }\n      resolve(app)\n    }, reject)\n    router.onError(reject)\n  })\n}\n</code></pre>\n</section>\n\n<section >\n\n<p>  浏览器端将预取的数据存放到vuex store中</p>\n<pre><code class="language-javascript">if (window.__INITIAL_STATE__) {\n  store.replaceState(window.__INITIAL_STATE__)\n}\n</code></pre>\n</section>\n\n<section >\n\n<p>  浏览器端数据预取需要注意二次获取的问题</p>\n<pre><code class="language-javascript">{\n  mounted () {\n    if (!this.$store.item) {\n      this.fetchItem() // 避免重复获取数据\n    }\n  },\n  methods: {\n    fetchItem () {\n      return this.$store.dispatch(&#39;fetchItem&#39;, this.$route.params.id)\n    }\n  }\n}\n</code></pre>\n</section>\n\n</section>\n\n').replace("<include_Li9jYWNoZS5tZA>","<section >\n\n\n<p>缓存</p>\n<section >\n\n<ul>\n<li>路由缓存</li>\n<li>组件缓存</li>\n</ul>\n</section>\n\n<section >\n\n<p>  路由缓存（页面缓存）</p>\n<p>  通常我们使用 micro-caching 的策略（短时缓存）</p>\n<ul>\n<li>一般我们只缓存静态页面，根据 url 和 cookie 等作为key缓存即可</li>\n<li>动态页面也可以缓存，但是要注意缓存key要包含所有动态要素</li>\n</ul>\n</section>\n\n<section >\n\n<p>  组件缓存</p>\n<p>  如果应用没有明显的性能问题不要使用组件缓存</p>\n<ul>\n<li>在创建render时传入缓存策略，一般选择LRU方法</li>\n<li> 需要缓存的组件需要指定 name 属性和 serverCacheKey 方法</li>\n<li>如果组件会对渲染上下文产生副作用或者依赖全局状态则不可缓存</li>\n</ul>\n</section>\n\n</section>\n\n");export default e;
