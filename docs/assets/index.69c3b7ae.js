export default'<script>\ndocument.title = \'Vite⚡️介绍\'\n<\/script>\n\n\n\n<section >\n\n<h2 id="vite"><a href="https://vitejs.dev/">Vite</a></h2>\n<p>  <img src="https://vitejs.dev/logo.svg" style="vertical-align:middle" width="100" alt="vite logo"></h3></p>\n<p>  Next Generation Frontend Tooling</p>\n<hr>\n  \x3c!--style=text-align: left--\x3e\n<p>  Vite是尤雨溪在去年推出的一款前端开发工具，它提供了与webpack+webpack-dev-server或者parcel相近的功能</p>\n  \x3c!--style=text-align: left--\x3e\n<p>  包括本地开发服务器，热更新，构建打包等，但无需配置开箱即用。</p>\n</section>\n\n<section data-background-color="var(--theme-color)" style="color: white">\n\n \n\n<section >\n\n<p>  同传统的工具相比，vite显著的快⚡️</p>\n<ul>\n<li>vite可以在s甚至ms内启动本地开发服务</li>\n<li>vite的热更新可以在毫秒量级生效</li>\n<li>vite生产构建时间也要显著小于webpack</li>\n</ul>\n</section>\n\n<section >\n\n<h3 id="为什么vite如此快？-">为什么vite如此快？ \x3c!-- style=color: rgb(249,215,87) --\x3e</h3>\n<ul>\n<li>无需打包 \x3c!--fragment--\x3e</li>\n<li>依赖预构建及硬盘缓存 \x3c!--fragment--\x3e</li>\n<li>依赖懒构建 \x3c!--fragment--\x3e</li>\n<li>使用esbuild \x3c!--fragment--\x3e</li>\n</ul>\n</section>\n\n</section>\n\n<section >\n\n \n\n<section >\n\n<h3 id="为何vite无需打包？">为何vite无需打包？</h3>\n<p>  因为目前主流浏览器早已原生支持es模块标准(使用<code>type=&quot;module&quot;</code>即可)</p>\n<p>  浏览器直接根据import去请求vite服务器</p>\n<p>  vite收到请求后会把对应的模块交给一系列plugin去处理成标准的es模块返回给浏览器</p>\n</section>\n\n<section >\n\n<h4 id="传统的构建工具是怎么做的？">传统的构建工具是怎么做的？</h4>\n<ul>\n<li>分析整个应用的依赖，递归地构建依赖树</li>\n<li>每个模块都要进行转换，排序，合并等等操作</li>\n<li>在完成这些之前，服务器是空白的</li>\n<li>应用越大，耗时越久</li>\n</ul>\n</section>\n\n<section >\n\n<p>  <img src="https://vitejs.dev/assets/bundler.37740380.png" alt=""></p>\n</section>\n\n<section >\n\n<p>  <img src="https://vitejs.dev/assets/esm.3070012d.png" alt=""></p>\n</section>\n\n</section>\n\n<section >\n\n \n\n<section >\n\n<p>  vite并不是完全不用打包，它会预先构建第三方依赖</p>\n  \x3c!--fragment--\x3e\n<ul>\n<li>第三方依赖的模块数量非常多，不打包会导致过多的http请求</li>\n<li>第三方依赖很多是commonjs格式，需要转换成esModule</li>\n</ul>\n</section>\n\n<section >\n\n<h3 id="vite对第三方依赖的构建策略">vite对第三方依赖的构建策略</h3>\n<ul>\n<li>vite默认不会构建任何依赖，直到浏览器访问了它 \x3c!--fragment--\x3e</li>\n<li>vite只会对依赖构建一次并缓存起来重复使用 \x3c!--fragment--\x3e</li>\n<li>每个依赖对应单个bundle，并充分利用协商缓存 \x3c!--fragment--\x3e</li>\n<li>vite使用<strong>极快</strong>的 <a href="https://esbuild.github.io/">esbuild</a> 构建依赖 \x3c!--fragment--\x3e</li>\n</ul>\n</section>\n\n</section>\n\n<section >\n\n \n\n<section >\n\n<p>  浏览器虽然原生支持import，但是仍有限制</p>\n  \x3c!--fragment--\x3e\n<ul>\n<li>引入的路径必须是绝对路径或相对路径或者完整url</li>\n<li>引入的资源响应类型必须是JavaScript类型</li>\n</ul>\n</section>\n\n<section >\n\n<p>  路径重写</p>\n<pre><code class="language-js">import { createApp } from &#39;vue&#39;\n// ==&gt; rewritten to:\n\nimport { createApp } from &#39;/@modules/vue&#39;\n// vite在收到来自/@modules的请求后会返回相应的第三方打包的依赖\n</code></pre>\n<ul>\n<li>import路径重写过程是相当迅速和轻量的（几毫秒），并不会把整个代码转为AST，仅仅只处理<code>import</code>语句 \x3c!--fragment--\x3e</li>\n<li>在<a href="https://github.com/WICG/import-maps" target="_blank">import-maps</a> 特性的支持下，理论上可以省去import重写的过程 \x3c!--fragment--\x3e</li>\n</ul>\n</section>\n\n<section >\n\n<p>  模块转换</p>\n<p>  vite支持将不是js的资源转换为js模块，但无需任何配置</p>\n<p>  例如vite会天然地将html当做entry，css-module也是内置支持，这些都是通过丰富的插件来实现的</p>\n</section>\n\n<section >\n\n<p>  vite采用基于rollup的插件系统</p>\n<p>  vite的插件系统是rollup插件的超集，完全兼容rollup生态 </p>\n<pre><code class="language-js">{\n  name: &#39;md-loader&#39;,\n  load(id) {\n    if (id.endsWith(&#39;.md&#39;)) {\n      const source = fs.readFileSync(id, &#39;utf8&#39;)\n      return `export default ${JSON.stringify(marked(source))}`\n    }\n  }\n}\n</code></pre>\n</section>\n\n<section >\n\n<p>  vite在构建阶段使用rollup来构建</p>\n<p>  实际上<code>rollup</code>不太适合用来打包业务应用，更适合打包库</p>\n<p>  vite通过一系列插件和预配置完善了这些功能，使得构建打包开箱即用</p>\n</section>\n\n</section>\n\n<section >\n\n<h3 id="热更新支持">热更新支持</h3>\n<ul>\n<li>内置对主流框架的热更新支持而无需额外配置</li>\n<li>支持自定义热更新插件（HMR Api）</li>\n</ul>\n  \x3c!--fragment--\x3e\n<pre><code class="language-javascript">export const count = 1\n\nif (false) {\n  false.accept((newModule) =&gt; {\n    console.log(&#39;updated: count is now &#39;, newModule.count)\n  })\n}\n</code></pre>\n</section>\n\n<section >\n\n<h3 id="其他特性概览">其他特性概览</h3>\n<section >\n\n\x3c!-- style=margin-top: 50px --\x3e\n<ul>\n<li><p>内置支持多种文件格式，html,vue,jsx,ts,tsx,json,postcss,css-module,scss,less,images,web-assembly,web-workers... </p>\n</li>\n<li><p>支持glob import</p>\n<pre><code class="language-js">const modules = import.meta.glob(&#39;./dir/*.js&#39;)\n// code produced by vite\nconst modules = {\n  &#39;./dir/foo.js&#39;: () =&gt; import(&#39;./dir/foo.js&#39;),\n  &#39;./dir/bar.js&#39;: () =&gt; import(&#39;./dir/bar.js&#39;)\n}\n</code></pre>\n</li>\n</ul>\n</section>\n\n<section >\n\n<ul>\n<li>css自动分包，压缩，url重写，内联data协议</li>\n<li>公用模块提取</li>\n<li>模块import alias支持</li>\n<li>更贴近语言标准的环境变量注入和替换，如 <code>({}).NODE_ENV</code></li>\n<li>SSR全流程支持（experimental）</li>\n<li>开箱即用的本地代理</li>\n<li>支持multi-page模式和library模式构建</li>\n</ul>\n</section>\n\n<section >\n\n<ul>\n<li>同时支持modern模式和legacy模式构建以及pre-标签注入</li>\n<li>vite dev server可以独立作为middleware使用</li>\n<li>支持构建阶段生成reporter和manifest</li>\n<li>丰富的项目模板，vue,react,svelte,preact,lit-element</li>\n<li>完整的TypeScript支持</li>\n<li>配置文件更改即时生效</li>\n<li>......</li>\n</ul>\n</section>\n\n</section>\n\n<section >\n\n<h4 id="和-vite-相似的工具">和 <code>vite</code> 相似的工具</h4>\n<ul>\n<li><a href="https://www.snowpack.dev/">snowpack</a></li>\n<li><a href="https://github.com/preactjs/wmr">wmr</a></li>\n<li><a href="https://modern-web.dev/docs/dev-server/overview/">@web/dev-server</a></li>\n</ul>\n</section>\n\n<section >\n\n<p>参考</p>\n<ul>\n<li><a href="https://vitejs.dev/">Vitejs</a></li>\n<li><a href="https://docs.google.com/presentation/d/1X1hrFw18v67bEniTPpaI_DBulLdkKNFEc_3nVEm95mM">Vite &amp; VitePress @ Vue Toronto 2020</a></li>\n<li><a href="https://antfu.me/posts/vue-beijing-2021">Develop with Vite - at Vue Beijing</a></li>\n</ul>\n<hr>\n<p>Q&amp;A</p>\n</section>\n\n';
